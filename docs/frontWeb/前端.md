### Typora使用

1. 标题

   一级标题	#	ctrl+1	

   二级标题	##	ctrl+2	

   ...

   六级标题	######	ctrl+6	

2. 有序列和无序列

   1. 有序列 
      - 1.加空格 2.加空格....
      - ctrl+shift+{	
   2. 无序列 
      - +-* 加空格
      - ctrl+shift+}

3. 文字加粗斜体

   1. 加粗

      - **文字 **  前后两个*号或下划线无空格
      - ctrl+b

   2. 斜体

      - *文字*  前后单个*无空格
      - ctrl+i

      

   3. 斜体加粗

      - ***斜体加粗文字***  前后三个*无空格

4. 文字下划线删除线高亮

   1. 下划线
      - <u>U下划线</u>  文字前 <u>   ，文字后  </u>中间无空格
      - ctrl+u

   2. 删除线
      - ~~删除线~~ 文字前后两个~~，无空格
      - alt+shift+5

   3. 高亮
      - ==高亮== 文字前后两个==，无空格

5. 代码块

   - <code>single world</code>	单个代码或一句代码用<code>方式

   - ~~~
     多行代码输入三个反引号~ 回车 在选择一个语言
     ~~~

     

### 命令

```js
本地数据库：
用户名:root
密码:root

//vm
ls(ll) 显示当前文件，ll更详细
pwd //显示当前所在的目录路径
touch index.js //新建js文件
mkdir img //新建img文件夹
rm index.js //删除js文件
rm -r img //删除 img文件夹


//xshell
sudo -i 超管
rm-f 删除文件
rm -rf 强制删除目录
rz -r 上传文件
unzip filename.zip 解压
zip filename.zip dirname 压缩


//git
git config -l 查看git环境的详细配置
git config --global user.name 'yangjie' 名称
git config --global user.email '914569804@qq.com' 邮箱
git branch //查看本地分支
git branch -a //查看本地和远程分支
git branch -D branchName //删除本地分支
git checkout -b branchName //切换新建分支
git push origin --delete BranchName //删除远程分支
git checkout branchName //切换分支
git checkout -t origin/branch //切换到远程分支branch 并自动切换到该分支 本地命名不变
git checkout -b branchA origin/branchB //切换远程分支B 并自动切换到该分支 本地命名分支A
git push --set-upstream origin branch //提交远程分支
git reset --hard xxx //回退到某个版本
git push -f //远程分支强制回退
git commit --amend修改还未提交的最后一次注释

git diff b1 b2 --stat //两分支所有差异列表文件 --stat显示列表
git diff b1 b2 fileName //两分支指定文件差异
git fetch origin develop:develop  
git merge origin/develop //当前分支拉远程其他分支 并合并


//nvm
nvm list available   #查看可安装的node版本号
nvm install 版本号   #安装node 例如：nvm install 14.19.0
nvm uninstall 版本号   #卸载node
nvm ls   #查看已安装成功的node版本
nvm use 版本号   #切换指定版本的node
nvm current   #查看当前所在node版本

//nrm   
//上传npm包，必须要设置默认npm源并登录。 
//因为下载时淘宝源更快，因此切换来切换去很很不方便，建议没有使用nrm的安装一下nrm管理npm源
npm i nrm -g
nrm ls //列出常用源
nrm use taobao //下载时用这个
nrm use npm //上传时用这个
npm login//去登陆 发布npm包
npm publish //上传
npm deprecate npm-test-moon@1.0.1 这个版本存在问题，请下载1.0.0版本 //npm deprecate 包名@版本号 提示信息。


//查看版本
nvm version 
node: node -v
npm: npm -v
cnpm: cnpm -v
vue-cli: vue -V
typescript: tsc -V
webpack:  webpack -v
java: javac -version
mysql: mysql --version
maven: mvn -version
react-native: npm info react-native


react-native 安装版本 jdk11 
npx react-native init chapter2 --version 0.68.2
```





### css

#### css盒模型

```js

标准盒模型：box-sizing: content-box, 宽高只有content 不包括padding/border/margin

怪异盒模型: box-sizing: border-box, 宽高包括(content padding border)
```



#### css超出隐藏

```js
一行隐藏
white-space:nowrap;
overflow:hidden;
text-overflow:ellipsis;

多行隐藏
word-break: break-all;
text-overflow: ellipsis;
overflow: hidden;
display: -webkit-box;
-webkit-line-clamp: 2;
-webkit-box-orient: vertical;
```



#### 像素与适配

- 像素px(pixel缩写)

  >
  >
  >它是图像显示的基本单位元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念，所以在谈论像素时一定要清楚它的上下文！

- 设备物理像素(物理像素)

  >
  >
  >显示屏是由一个个**物理像素**点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的**物理像素点**就固定不变了。也即常说的分辨率 如: 1920X1080 , 750X1334

- 设备独立像素(也称逻辑像素 或dip)

  >
  >
  >设备独立像素”也有人称为“CSS像素”，一种形象的说法，更倾向于表明与 `CSS` 中尺寸的对应。
  >通过window.screen.width`/`window.screen.height查看
  >
  >为什么会有设备独立像素?
  >
  >假设，我有一个iPhone12 和 iPhone13，尺寸都是5.4，iphone12的分辨率是**1040\*960**， iphone13的分辨率是**2080×1170**，那么，ihpone12有1170个物理像素，iphone有2532个物理像素。
  >
  >如果按照真实物理像素进行布局，以12为例，那么到13上，又会出现一半的空白，为了避免这种情况的出现，出现了**虚拟像素单位**，我们统一12和13的虚拟像素都是1040个，只是在12上，1个虚拟像素被换算成1个物理像素，在13上，1个虚拟像素，被换算成2个物理像素。
  >
  >这种`n个虚拟像素:n个物理像素`比例式的换算，被统称为`设备像素比`，也就是`dpr`

- dpr(设备像素比)

  >
  >
  >在移动端浏览器中以及某些桌面浏览器中，window对象有一个`devicePixelRatio`属性， 
  >它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 **devicePixelRatio = 物理像素 / 独立像素**。

- ppi(像素密度)

  >
  >
  >每英寸像素，即每英寸所包含的像素点数目，也就是像素密度，数值越高，屏幕越能以更高的密度
  >
  >![image-20220901233737020](C:\Users\yangjie\AppData\Roaming\Typora\typora-user-images\image-20220901233737020.png)

- viewport

  >通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。
  >
  >移动端默认viewport是980，因为早期的pc网页布局版心是900左右
  >这样pc网站放在手机**viewport布局**上时就不会出现滚动条，就能全部承载网页内容
  >但是这个视口只是一个虚拟的视口，真实呈现大小还是**依移动端独立像素大小**尺寸来呈现，
  >这样就会出现在默认情况下(不设置meta viewport大小 默认取980)原本需要在980可以全部展示的东西需要缩放至独立设备像素大小尺寸呈现，缩放比例scale = 独立设备像素/980。   window.visualViewport可获取视口独立像素和缩放比例
  >
  >我们把默认的这个viewport叫做 **layout viewport**可以通过document.documentElement.clientWidth获取
  >
  >把可视区域宽度 也就是移动设备独立像素的视口叫做**visual viewport**可以通过window.innerWidth
  >
  >把缩放后的viewport就是ideal viewport可以通过meta设置**ideal viewport**的值

  ppk把移动设备上的viewport分为***layout viewport*** 、 ***visual viewport***  和 ***ideal viewport*** 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。
  
- rem

  >
  >
  >根据以上我们知道，如果以设计稿尺寸(如750)做的网页，放在iphone6上(375X667)时候，如果没有设置meta viewport时候，移动端会使用默认980作为viewport，测试全部展示750尺寸在 Iphone6上只是会缩小，因为需要把980尺寸缩小到375尺寸大小
  >
  >如果设置了 <meta name="viewport" content="width=device-width, initial-scale=1.0">，那即ideal viewport的尺寸是取设备独立像素375，此时750尺寸就会超出可视区域出现滚动条， 
  >
  >因此我们开发移动端时候，最好的展现效果就是 1.视口全部展示网页内容，2.网页不出现缩放和滚动条，因此需要配置上
  >meta  content="width=device-width, initial-scale=1.0" 同时按照设备的独立像素大小进行设计开发， 
  >
  >但是往往会不同尺寸设计稿，如果需要做到适配不同手机，此时就需要进行一个换算， 在设置meta viewport的情况下，
  >
  >如果设计稿尺寸750，放在6p 414独立像素上进行展示，此时设计稿50px东西需要展示在414上,给设计稿尺寸等比缩放，为: 414/750 X 50 =   27.6px,  就需要写成27.6px, 换算成rem，如果根元素设置为font-size:100px, 即可写成0.276rem, 
  >
  >但是这样书写特别麻烦 每次需要取计算， 能不能规定50px就是50/100=0.5rem， 此时font-size就不能是100px
  >
  >这个100px怎么来的，  因为我们知道设计稿50px东西在414布局上展示27.6是固定的把，  因此需要如下计算
  >
  >```js
  >x为需要设置的font-size根元素大小
  >
  >414/750 * 50 = 50/100 * X
  >x = (414*100) / 750，  
  >// 100即我们规定的那个参数  
  >// 设计稿上量出的大小直接除以100 得到的就是rem值
  >
  >
  >//以可以这样计算过程
  >                    100px     html 根字体大小
  >修改比例公式为:       —————  =  ———————————————
  >                    750px     设备尺寸宽度大小
  >
  >                    100px * 设备尺寸宽度大小
  >html 根字体大小 =    ——————————————————————
  >                            750px
  >                            
  >                            
  >
  ><head>
  ><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
  ><script>
  >const WIDTH = 750 //设计稿尺寸
  >const setView = () => {
  > document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + 'px'
  >}
  >window.onorientationchange = setView
  >setView()
  ></script>
  ></head>
  >```
  >
  >

- VM

  >
  >
  >rem 是相对于根元素(html)的 font-size。
  >vw和vh是基于显示屏幕的宽高，相当于100等份，我觉得跟百分比类似，只不过百分比受父级节点限制，而vh和vw不会，只基于屏幕宽高。
  >
  >postcss-px-to-viewport 配合这个插件使用 效果更佳



### sass

>简言之可以理解scss是sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力。语法形式上有些许不同，最主要的就是sass是靠缩进表示嵌套关系，scss是花括号

#### 变量

```js
sass使用$符号来标识变量 less用@
$nav-color: #F90;
nav {
  $width: 100px;
  width: $width;
  color: $nav-color;
}
```

#### 嵌套

#### 导入

```js
@import
css和sass都可以用这个导入

区别在于：
css只有执行到@import时候浏览器才会去下载css文件 这导致页面加载起来比较慢
sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求
```

#### 静默注释

```js
css中的注释是/*..*/ 可以直接看到生成的注释
sass注释//  不会生成到css中
```

#### 混合

```js
@mixin 定义混合
@include 导入混合

//定义
@mixin rounded-corners {
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

//导入
notice {
  background-color: green;
  border: 2px solid #00aa00;
  @include rounded-corners;
}

给混合器传参
@mixin link-colors($normal, $hover, $visited) {
  color: $normal;
  &:hover { color: $hover; }
  &:visited { color: $visited; }
}
a {
  @include link-colors(blue, red, green);
}

```

#### 继承

```js
@extend 

.error {
  border: 1px solid red;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

#### 指令

```js
$colorList:(red:red, blue:blue, yellow:yellow);
@each $header,$value in $colorList{
    .m-color-#{$header}{
        background-color:#{$value}
    }
} 
```





### 浏览器

#### 浏览器回收机制

>  js在创建变量时 系统会自动为变量分配内存，在不使用这些变量的时候会自动周期性的释放内存，释放过程就叫“垃圾回收”
>
>  + 标记清楚
>
>    当变量进入执行环境（函数中声明变量,执行时）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量
>
>  + 引用清楚
>
>    引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来



#### 事件冒泡和默认行为

~~~js
// 当需要停止冒泡行为时，可以使用
function stopBubble(e) { 
    //如果提供了事件对象，则这是一个非IE浏览器 
    if ( e && e.stopPropagation ) 
        //因此它支持W3C的stopPropagation()方法 
        e.stopPropagation(); 
    else 
        //否则，我们需要使用IE的方式来取消事件冒泡 
        window.event.cancelBubble = true; 
}


//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}
reture false 会同时阻止默认事件和冒泡行为


网景主张捕获，微软主张冒泡，w3c平息战火折中方案-先捕获再冒泡
document.addEventListenter(event,function,useCapture)
第三个参数默认false，表示在事件冒泡阶段掉用事件处理函数, 如果true表示在事件捕获阶段调用处理函数
~~~



#### BOM

##### window

>Bom的核心对象是window, 它标识一个浏览器实例，也是ECMAScript规定的Globle对象
>
>
>
>定义的全局变化不能通过delete删除 而直接在window上定义的属性可以
>var age = 29
>window.color = "red"
>delete window.age // ie<9报错 其他返回false
>delete window.age //ie<9报错 其他返回true
>
>
>
>常用方法：
>alert()
>setTimeout()
>setTimeInterval()
>closed()
>moveBy(x,y)  //把窗口右移x像素 下移y像素 
>moveTo(x,y) //把窗口左上角移动到指定位置  x,y是坐标值
>open()
>print()



##### navigator

>保存着浏览器的各种信息，常用userAgent来判断浏览器类型









### 数据类型

#### null undefined

```js
console.log(null==undefined);    //true  因为两者都默认转换成了false
console.log(typeof undefined);    //"undefined"  
console.log(typeof null);       //"object"  
console.log(null===undefined);    //false   "==="表示绝对相等，null和undefined类型是不一样的，所以输出“false”


null和undefined转换成number数据类型
null 默认转成 0
undefined 默认转成 NaN

undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。
```

#### Object

##### Object.freeze()

```js
Object.freeze() 方法可以冻结一个对象，是浅冻结， 如果要深冻结需要递归

const objectExample = {
	prop1: 20,
	prop2: '羊先生',
}

// 默认情况下，我们可以根据需要修改对象的属性
objectExample.prop1 = 100
console.log(objectExample.prop1)

// 冻结对象
Object.freeze(objectExample)
objectExample.prop2 = 'Alice' // 如果在严格模式会抛出失败，在非严格模式下只会抛出异常
console.log(objectExample.prop2)

const theObject = {
	x: 1,
	z: 2,
	y: {
		a: 'Hello',
		b: '羊先生',
	},
}

Object.freeze(theObject)
theObject.x = 100
console.log(theObject.x) //1
theObject.y.a = 'vipbic'
console.log(theObject.y.a) //vipbic 并没有冻结深层次对象

//深冻结
const theObject = {
	x: 1,
	z: 2,
	y: {
		a: 'Hello',
		b: '羊先生',
	},
}

const deepFreeze = (obj) => {
	const propNames = Object.getOwnPropertyNames(obj)
	for (const name of propNames) {
		const value = obj[name]
		if (value && typeof value === 'object') {
			deepFreeze(value)
		}
	}
	return Object.freeze(obj)
}

deepFreeze(theObject)
theObject.y.a = 100
console.log(theObject.y.a) // hello

```





### 原型和原型链 

原型链：当访问属性的对象或方法的时候，首先会从自身去找 如果找不到的话，他就会往他的原型上去找，如果原型上还找不到就回继续往原型的原型上去找，这样一条链式的结构 我们称之为原型链

![image-20220529012719270](C:\Users\yangjie\AppData\Roaming\Typora\typora-user-images\image-20220529012719270.png)



### encodeURI 

encodeURI和encodeURLComponent, decodeURI和decodeURIComponent

- encodeURI 针对整个url进行编码  可以对url中空格转化为20% 其他特殊字符不做处理(冒号 反斜杠 问好 井号等)

- encodeURIComponent 针对url中带的参数进行编码 会对发现的任何特殊字符进行编码

- decodeURI和decodeURIComponent 对上述两个进行解码，

  decodeURI只对20%进行解码为空格  其他特殊字符不做解码， decodeURIComponent对任何特殊字符进行解码

~~~ js
var uri = "http://www.wrox.com/illegal value.htm#start";

//"http://www.wrox.com/illegal%20value.htm#start"
alert(encodeURI(uri));

//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"
alert(encodeURIComponent(uri));

var uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";

//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start
alert(decodeURI(uri));

//http://www.wrox.com/illegal value.htm#start
alert(decodeURIComponent(uri)); 


~~~





### js模块化

#### commonjs

- 在服务端：模块的加载是运行时同步加载
- 在浏览器端：模块需要提前编译打包处理

```js
暴露模块:
module.exports = value
exports.xx = value
暴露的是exports

引入模块:
require(xx)
```

#### AMD

- 专门用于浏览器端，模块的加载是异步的 require.js

  ```js
  暴露模块
  1.没有依赖模块
  define(function(){
      return 模块
  })
  
  2.有依赖模块
  define(['module1','module2'],function(m1,m2){
      return 模块
  })
  
  引入模块
  require(['module1','module2'],function(m1,m2){
      使用m1/m2
  })
  ```

  

#### CMD

- 专门用于浏览器端，模块的加载是异步的 模块使用时才会加载 sea.js

```js
暴露模块
1.定义没有依赖的模块
define(function(require,exports,module){
    
    exports.xx = value
    module.exports = value
})

2.定义有依赖的模块
define(function(require,exports,module){
    //引入依赖模块 同步
    var module2 = require('./module2')
    //引入模块 异步
    require.async('./module2',function(m3){
        
    })
    //暴露模块
    exports.xx = value
})

引入模块
define(function(require){
    var m1 = require('./module1');
    var m4 = require('./module4');
    
    m1.show()
    m4.show()
})
```

### Object.freeze()

```js

1.定义const基本数据类型 值不可修改, 但是定义引用数据类型 可以修改
const a = 5;
a = 55; // Assignment to constant variable.

const b = { bb:55 }
b.bb = 66; //ok

如果想定义一个不可修改的对象 可以使用Object.freeze() 
不能添加新属性
不能删除已有属性
不能修改已有属性的值
不能修改原型
不能修改已有属性的可枚举性、可配置性、可写性

Object.freeze(b); 
b.bb = 77;
console.log(b.bb); //66 还是原来值没修改，

但是如果对象是深层次的 则Obejct.freeze()修改不了; 可以使用递归定义一个深冻结

function deepFreeze(obj){
    const propsNames = Object.getOwnPropertyNames(obj);
    
    propsNames.forEach( el =>{
        var prop = obj[el]
        if(prop instanceof Object && prop != null){
            deepFreeze(el)
        }  
    })
    
    return Object.freeze(obj
}



```





#### ES6

- 依赖模块需要打包处理

```js
导出模块:export

引入模块:import

实现(浏览器端) 
使用Babel将es6编译为es5代码，使用Browserify编译打包js

```



#### exports和module.exports

exports === module.exports 都是指向同一个内存地址 module.exports.xx == exports.xx

暴露的本质是exports对象

1. module.exports有两种使用方式

   module.exports = xx

   module.exports = { }

2. exports只有一种使用方式

   exports.xx = 

#### export和export default

1. export与export default均可用于导出常量、函数、文件、模块等
2. .你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用
3. 在一个文件或模块中，export、import可以有多个，export default仅有一个
4. 通过export方式导出，在导入时要加{ }，export default则不需要





### vue



### es6

#### 可选链?.  空值合并??  ||逻辑或

```js
let obj = {
    a: '1'
}

console.log(obj?.b.bb) // undefined
console.log(obj.b.bb) //页面报错崩了  

可选链可以允许读取位于连接对象深处的属性值，而不必明确验证链中的每个引用是否有效

null ?? '11' -->'11'
undefined ?? '11' -->'11
0 ?? '11' --> '0'
'' ?? '11' --> ''
??空值合并操作符只当左侧操作数为null/undefined时，返回右边的数否则返回左边的操作数 0，/，''虽然假值但不是null/undefined所以返回原操作数

null || '22'
nudefined || '22'
0 || '22'
'' || '22'
以上都返回'22' 逻辑或当左侧为假值时候就返回右侧数据 否则返回左边数据
```



### 字符串

#### 字符串的操作

字符串的特点一旦创建就不可变，所有的增删改操作都是创建一个副本后再操作

```js
增：
这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作 
除了常用+以及${}进行字符串拼接之外，还可通过concat

let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"

删：
这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作
这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。 
如果没有第二个参数返回从第一个参数开始(包含第一个参数)到字符串结尾
开始位置下标都从是0开始
slice/subsring第二个参数是结束位置   返回不包含第二个参数结束位置字符
substr第二个参数是长度 返回包含总共几个字符

slice()
substr()
substring()

let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"


改：
这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作

trim()、trimLeft()、trimRight()
删除前、后或前后所有空格符，再返回新的字符串
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello world "
console.log(trimmedStringValue); // "hello world"

repeat()
接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果
let stringValue = "na ";
let copyResult = stringValue.repeat(2) // na na 

padEnd()
复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
let stringValue = "foo";
console.log(stringValue.padStart(6)); // " foo"
console.log(stringValue.padStart(9, ".")); // "......foo"

toLowerCase()、 toUpperCase()
let stringValue = "hello world";
console.log(stringValue.toUpperCase()); // "HELLO WORLD"
console.log(stringValue.toLowerCase()); // "hello world"

查：
除了通过索引的方式获取字符串的值，还可通过：
chatAt()
返回给定索引位置的字符，由传给方法的整数参数指定
let message = "abcde";
console.log(message.charAt(2)); // "c"


indexOf()
从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）
let stringValue = "hello world";
console.log(stringValue.indexOf("o")); // 4

includes():返回布尔值，表示是否找到了参数字符串。
startsWith():返回布尔值，表示参数字符串是否在原字符串的头部。
endsWith():返回布尔值，表示参数字符串是否在原字符串的尾部。
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("bar")); // false
console.log(message.includes("bar")); // true
console.log(message.includes("qux")); // false

```



#### slice() & splice()

```js
索引都是从0开始
slice字符串和数组都存在的方法 用来做截取元素，不修改原始值 返回一个副本
splice仅数组存在方法 用来新增/删除数组元素，修改原始值，并返回删除的元素


slice(i,j) 
1.不修改原始字符串/数组
2.返回新的字符串/数组 返回位置从i(包含)到j(不包含) 如果没有j返回从i(包含)到结尾
3.索引负数从结尾倒叙开始


splice(index,howmany,item1,itemx) 
index: 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
howmany: 必需。要删除的项目数量。如果设置为 0，则不会删除项目。
item1...itemX : 可选。向数组添加的新项目。
返回值 Array  包含被删除项目的新数组，如果有的话。

let a = ['11','22','33','44']
console.log(a.splice(1,2,'kk')) // ['22', '33']
console.log(a) // ['11', 'kk', '44']

```





### 对象

#### 判断对象是否为空 

```js
1 使用JSON.stringify 不推荐
    if(JSON.stringify(Obj) == '{}'){
        console.log('空对象');
    }

2 for in 遍历属性，为真则为非空数组 否则为空数组
    function judgeObj(Obj){
        for(var attr in Obj){
            return alert('非空对象')
        }
        return alert('空对象')
    }

3 ES6新增的方法Object.keys():
    if(Object.keys(Obj).length > 0){//会转化一个数组
        console.log('非空对象');
    }

```





#### 判断对象上是否有某个属性

```js
1 点( . )或者方括号( [ ] )
    // 创建对象
    let test = {name : 'lei'}
    // 获取对象的自身的属性
    test.name            //"lei"
    test["name"]         //"lei"

    // 获取不存在的属性
    test.age             //undefined

    // 获取原型上的属性
    test["toString"]     //toString() { [native code] }

    // 新增一个值为undefined的属性
    test.un = undefined

    test.un              //undefined    不能用在属性值存在，但可能为 undefined的场景

	所以，我们可以根据 obj.x 是否为 undefined 的返回值 来判断obj是否有x属性。这种方式很简单方便，局限性就是：不能用在x的属性	值存在，但可能为 undefined的场景。 in运算符可以解决这个问
    
2  in 运算符
    // 创建对象
    let test = {name : 'lei'}

    'name' in test        //true

    'un' in test             //true

    'toString' in test    //true

    'age' in test           //false

    示例中可以看出，值为undefined的属性也可正常判断。这种方式的局限性就是无法区分自身和原型链上的属性，在只需要判断自身属性是否	  存在时，这种方式就不适用了。这时需要hasOwnProperty()  

3 hasOwnProperty()

    test.hasOwnProperty('name')        //true   自身属性
    test.hasOwnProperty('age')           //false  不存在
    test.hasOwnProperty('toString')    //false  原型链上属性

    可以看到，只有自身存在该属性时，才会返回true。适用于只判断自身属性的场景。

```



### node

#### fs

```js

fs:文件系统模块 
fs.readFile() 用来读取文件内同
fs.writeFile() 用来向指定文件写入内容

const fs = require('fs')
//options编码格式 可选属性 默认utf8
fs.readFile(path[,options],function(err,data){
    //如果读取成功err null, data为读取数据
    //如果读取失败err 为错误对象, data为undefined
})

//data 写入的内容 options可选默认utf8
fs.writeFile(file,data[,options],function(err){
    //如果写入成功err null
    //如果写入失败err 为错误对象
})


//代码在运行时 会以"执行node命令时所处的目录", 动态拼接出被操作文件的完整路径


```



#### path

```js

path.join([...paths])
可以把多个路径片段拼接成完整的路径字符串
const path = require('path')

const str = path.join('/a','/b/c','../','./d','e')
console.log(str)  //  \a\b\d\e

//__dirname当前目录
const str2 = path.join(__dirname,'./files/1.txt')
console.log(str2)  //当前目录\files\1.txt

fs.readFile(path.join(__dirname,'./1.txt'),'utf8',function(err,data){
    //使用path.join拼接路径
})

path.resolve()
会把一个路径或路径片段的序列解析为一个绝对路径。
join是把各个path片段连接在一起， resolve把'/'当成根目录
path.join('/a', '/b'); 
// /a/b
path.resolve('/a', '/b');
// /b
一句话，path.join()从左往右，将传入的path片段拼接成一个完成的地址。path.resolve() 从右往左将path片段拼成绝对路径。


path.baseename(path[,ext])
获取路径中的最后一部分经常使用这个方法获取文件名， ext文件扩展名

const fpath = '/a/b/c/index.html'
const fname = path.basename(fpath)
console.log(fname)  //index.html

const nameWithoutExt = path.basename(fname,'.html')
console.log(nameWithoutExt)  //index  移除.html扩展名

path.extname(path) 获取文件扩展名
const fpath = '/a/b/c/index.html'
const fext = path.extname(fpath)
console.log(fext)  //.html

```



#### http

```js
//1导入http模块
const http = require('http');

//2创建web服务器实例
const server = http.createServer()


//3为服务器绑定request事件，监听客户端请求
server.on('request',(req,res)=>{
    //req.url  客户点请求url
    //req.method 客户端请求类型
    
    
    //res.end() 向客户端发送指定内容 并结束这次请求的处理过程
    const str = `your request is ${req.url} and methods is ${req.method}` 
    
    //解决乱码
    res.setHeader('Content-Type','text/html; charset=utf-8')
    res.end(str)
    
})


//4启动服务器
server.listen(3000,=>{
	console.log('http server running at http://127.0.0.1:3000')
})

```



#### express

```js
//导入express
const express = require('express')

//创建web服务器
const app = express()

//启动web服务器
app.listen(80,()=>{
    console.log('express server running at http://127.0.0.1')
})


//express路由 app.METHOD(PATH,HANDLER)

//get请求
app.get('url',function(req,res){
    //把内容响应给客户端
    res.send('返回内容')
})
//post请求
app.post('url',function(req,res){
     res.send('返回内容')
})
//获取url参数 req.query req.params
app.get('/:id',(req,res)=>{
    console.log(req.query)  //获取?后面参数
    console.log(req.params) //获取:后面参数
    res.send(req.query)
})

//托管静态资源
express.static() 通过它我们可以非常方便的创建一个静态资源服务器
app.use(express.static('plubic'))
```



#### router

```js
//router.js
let express = require('express')
let Router = express.Router()

Router.get('/',()=>{
    
})

module.exports = Router


//index.js
let express = require('express')
let app = express()

//引入当如router
let Router = require('./router')
app.use(Router)
//为路由添加统一前缀
app.use('/use',Router())


//启动服务器
app.listen(80,()=>{
    
})


```



#### nodemon

```js
npm install nodemon -g

用nodemon取待node启动项目 可以随时监听监听变化不需要重启项目
```



#### 中间件

```js
const mw = function(req,res,next){

	next()
}


// 全局中间件
app.use(mw)
//等价写法 通常用下面这个
app.use(function(req,res,next){
    next()
})

// 局部中间件 在路由url和回调之间
app.get('/',mw,function(req,res){
  res.send()
})


```



### typescript

类型检查按照**【类型检查的时机】**来分类 可以分为动态类类型和静态类型

动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误

静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误

Js是一门解释型语言 没有编译阶段 所以它是**动态类型**

ts在运行前需要先编译js 在编译阶段就类型类型检查 所以ts是**静态类型**

类型系统按照**【是否允许隐式类型转换】**来分类 可以分为强类型和若类型

```js
console.log(1+'1') //'11'

这个在js和ts中都可以正常运行 运行时数字1会被隐式类型转换成为字符串'1'  加号+被识别为字符串拼接所以打印出结果是字符串'11'
ts完全兼容js 不会修改js运行时的特性，所以他们都是弱类型
```



#### 基本类型

TypeScript中的基本类型：

- 类型声明

  - 类型声明是TS非常重要的一个特点；

  - 通过类型声明可以指定TS中变量（参数、形参）的类型；

  - 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；

  - 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；

  - 语法：

    - ```
      let 变量: 类型;
      
      let 变量: 类型 = 值;
      
      function fn(参数: 类型, 参数: 类型): 类型{
          ...
      }
      ```

- 自动类型判断

  - TS拥有自动的类型判断机制
  - 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型
  - 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明

- 类型：

  | **类型** | **例子**          | **描述**                       |
  | -------- | ----------------- | ------------------------------ |
  | number   | 1, -33, 2.5       | 任意数字                       |
  | string   | 'hi', "hi", `hi`  | 任意字符串                     |
  | boolean  | true、false       | 布尔值true或false              |
  | 字面量   | 其本身            | 限制变量的值就是该字面量的值   |
  | any      | *                 | 任意类型                       |
  | unknown  | *                 | 类型安全的any                  |
  | void     | 空值（undefined） | 没有值（或undefined）          |
  | never    | 没有值            | 不能是任何值                   |
  | object   | {name:'孙悟空'}   | 任意的JS对象                   |
  | array    | [1,2,3]           | 任意JS数组                     |
  | tuple    | [4,5]             | 元素，TS新增类型，固定长度数组 |
  | enum     | enum{A, B}        | 枚举，TS中新增类型             |

- number

  - ```js
    let decimal: number = 6;
    let hex: number = 0xf00d;
    let binary: number = 0b1010;
    let octal: number = 0o744;
    let big: bigint = 100n;
    ```

- boolean

  - ```js
    let isDone: boolean = false;
    ```

- string

  - ```js
    let color: string = "blue";
    color = 'red';
    
    let fullName: string = `Bob Bobbington`;
    let age: number = 37;
    let sentence: string = `Hello, my name is ${fullName}.
    
    I'll be ${age + 1} years old next month.`;
    ```

- 字面量

  - 也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围

  - ```js
    let color: 'red' | 'blue' | 'black';
    let num: 1 | 2 | 3 | 4 | 5;
    ```

- any

  - ```js
    let d: any = 4;
    d = 'hello';
    d = true;
    ```

- unknown

  - ```js
    let notSure: unknown = 4;
    notSure = 'hello';
    ```

- void

  - ```js
    let unusable: void = undefined;
    ```

- never

  - ```js
    function error(message: string): never {
      throw new Error(message);
    }
    ```

- object（没啥用）

  - ```
    let obj: object = {};
    ```

- array

  - ```js
    let list: number[] = [1, 2, 3];
    let list: Array<number> = [1, 2, 3];
    ```

- tuple

  - ```js
    let x: [string, number];
    x = ["hello", 10]; 
    ```

- enum

  - ```js
    enum Color {
      Red,
      Green,
      Blue,
    }
    let c: Color = Color.Green;
    
    enum Color {
      Red = 1,
      Green,
      Blue,
    }
    let c: Color = Color.Green;
    
    enum Color {
      Red = 1,
      Green = 2,
      Blue = 4,
    }
    let c: Color = Color.Green;
    ```

- 类型断言

  - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：

    - 第一种

      - ```
        let someValue: unknown = "this is a string";
        let strLength: number = (someValue as string).length;
        ```

    - 第二种

      - ```
        let someValue: unknown = "this is a string";
        let strLength: number = (<string>someValue).length;
        ```





#### Null 和 Undefined

```js
在ts中可以使用null undefined来定义这两个原始数据类型
let u:undefined = undefined
let n:unll = null


与void的区别 null和undefined是所有类型的子类型 也就是说undefined类型的变量 可以赋值给其他类型
let num:number = undefined
```



#### any和unkonw

```js
//定义any类型 可以被赋值任意类型
let m:any = 'hello'
m = 123  //ok


//如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：
let d; //相当于let d:any
d = 10
d = 'hello'
d = false
都OK

let e:unkonw 表示未知类型的值
e = 10
e = 'hello'
e = fale 
都KOK

let s:string
s = d; //可以复制 d的类型是any 他可以赋值给任意类型
s = e; //报错 unkonw不可以赋值


any不止可以霍霍自己也可以霍霍别人 unkonw只霍霍自己不霍霍别人
```



#### void和never

```js
//void 用来表示空 以函数为例就表示没有返回值的函数 
function fn():void{
    //下面两个可以
    //return null  
    //return undefined
}

//never表示永远不会有返回结果 连空都没有
function fn():never{
    throw new Error('报错了')
}
```

#### 联合类型

```js
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：
function getLength(something: string | number): number {
    return something.length;
}
上例中，length 不是 string 和 number 的共有属性，所以会报错。

访问 string 和 number 的共有属性是没问题的：
function getString(something: string | number): string {
    return something.toString();
}

联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5
myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错

// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'
上例中，第二行的 myFavoriteNumber 被推断成了 string，访问它的 length 属性不会报错。

而第四行的 myFavoriteNumber 被推断成了 number，访问它的 length 属性时就报错了。
```



#### 编译选项

自动编译文件:  

编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

示例：

```
  tsc xxx.ts -w
```

##### 

自动编译整个项目:  

如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。

**但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json**

tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译

配置选项：

##### **include**

- 定义希望被编译文件所在的目录
- 默认值：["**/*"]

示例：

```
  "include":["src/**/*", "tests/**/*"]
```

上述示例中，所有src目录和tests目录下的文件都会被编译

##### **exclude**

- 定义需要排除在外的目录
- 默认值：["node_modules", "bower_components", "jspm_packages"]

示例：

```
  "exclude": ["./src/hello/**/*"]
```

上述示例中，src下hello目录下的文件都不会被编译

##### **extends**

- 定义被继承的配置文件

示例：

```
"extends": "./configs/base"
```

上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息

##### **files**

- 指定被编译文件的列表，**只有需要编译的文件少时才会用到**

示例：

```
"files": [
    "core.ts",
    "sys.ts",
    "types.ts",
    "scanner.ts",
    "parser.ts",
    "utilities.ts",
    "binder.ts",
    "checker.ts",
    "tsc.ts"
  ]
```

- 列表中的文件都会被TS编译器所编译

##### compilerOptions

- 编译选项是配置文件中非常重要也比较复杂的配置选项
- 在compilerOptions中包含多个子选项，用来完成对编译的配置

项目选项：

- target

  - 设置ts代码编译的目标版本

  - 可选值：

    - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext

  - 示例：

    - ```
      "compilerOptions": {
          "target": "ES6"
      }
      ```

  - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码

- lib

  - 指定代码运行时所包含的库（宿主环境）

  - 可选值：

    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......

  - 示例：

    - ```
      "compilerOptions": {
          "target": "ES6",
          "lib": ["ES6", "DOM"],
          "outDir": "dist",
          "outFile": "dist/aa.js"
      }
      ```

- module

  - 设置编译后代码使用的模块化系统

  - 可选值：

    - CommonJS、UMD、AMD、System、ES2020、ESNext、None

  - 示例：

    - ```
      "compilerOptions": {
          "module": "CommonJS"
      }
      ```

- outDir

  - 编译后文件的所在目录

  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置

  - 示例：

    - ```
      "compilerOptions": {
          "outDir": "dist"
      }
      ```

    - 设置后编译后的js文件将会生成到dist目录

- outFile

  - 将所有的文件编译为一个js文件

  - 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中

  - 示例：

    - ```
      "compilerOptions": {
          "outFile": "dist/app.js"
      }
      ```

- rootDir

  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录

  - 示例：

    - ```
      "compilerOptions": {
          "rootDir": "./src"
      }
      ```

- allowJs

  - 是否对js文件编译

- checkJs

  - 是否对js文件进行检查

  - 示例：

    - ```
      "compilerOptions": {
          "allowJs": true,
          "checkJs": true
      }
      ```

- removeComments

  - 是否删除注释
  - 默认值：false

- noEmit

  - 不对代码进行编译
  - 默认值：false

- sourceMap

  - 是否生成sourceMap
  - 默认值：false

- 严格检查

  - strict
    - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查
  - alwaysStrict
    - 总是以严格模式对代码进行编译
  - noImplicitAny
    - 禁止隐式的any类型
  - noImplicitThis
    - 禁止类型不明确的this
  - strictBindCallApply
    - 严格检查bind、call和apply的参数列表
  - strictFunctionTypes
    - 严格检查函数的类型
  - strictNullChecks
    - 严格的空值检查
  - strictPropertyInitialization
    - 严格检查属性是否初始化

- 额外检查

  - noFallthroughCasesInSwitch
    - 检查switch语句包含正确的break
  - noImplicitReturns
    - 检查函数没有隐式的返回值
  - noUnusedLocals
    - 检查未使用的局部变量
  - noUnusedParameters
    - 检查未使用的参数

- 高级

  - allowUnreachableCode
    - 检查不可达代码
    - 可选值：
      - true，忽略不可达代码
      - false，不可达代码将引起错误
  - noEmitOnError
    - 有错误的情况下不进行编译
    - 默认值：false





#### webpack打包ts配置

```js
const path = require('path')
const HTMLWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const { resolve } = require('path')

module.exports = {
	// 入口
	entry: './src/index.ts',
	// 指定打包文件所在目录
	output: {
		path: path.resolve(__dirname, 'dist'),
		filename: 'bundle.js',
        environment:{
            arrowFunction:false //箭头函数编译普通函数
        }
	},
	mode: 'development',
	// 指定webpack打包时使用的模块
	module: {
		// 指定要加载的规则
		rules: [
			{
				// test 指定的是规则生效文件
				test: /\.ts$/,
				use: [
					// 配置'babel-loader'
					{
                        loader:'babel-loader',
                        options:{
                            // 设置预定义的环境
                            presets:[
                                [
                                     // 指定环境插件
                                    "@babel/preset-env",
                                    // 配置信息
                                    {
                                        // 要兼容的目标浏览器
                                        targets: {
                                            "chrome":"58",
                                            "ie":"11"
                                        },
                                        // 指定corejs版本
                                        "corejs":"3",
                                        // 使用corejs的方式 usage表示按需加载
                                        useBuiltIns: "usage"
                                    }
                                ]
                            ]
                        }
                    },
					'ts-loader',
				], //从后往前转换
				exclude: /node-modules/,
			},
		],
	},
	// 配置webpack 插件
	plugins: [
		new CleanWebpackPlugin(),

		new HTMLWebpackPlugin({
			// title: '自定义title',
			template: './index.html',
		}),
	],
	resolve: {
		extensions: ['.ts', '.js'],
	},
}




//packjson.js
{
  "name": "ts",
  "version": "1.0.0",
  "description": "this is a demo ",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack",
    "start": "webpack serve --open"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.17.8",
    "@babel/preset-env": "^7.16.11",
    "babel-loader": "^8.2.4",
    "clean-webpack-plugin": "^4.0.0",
    "core-js": "^3.21.1",
    "html-webpack-plugin": "^5.5.0",
    "ts-loader": "^9.2.8",
    "typescript": "^4.6.3",
    "webpack": "^5.71.0",
    "webpack-cli": "^4.9.2",
    "webpack-dev-server": "^4.8.0"
  }
}
```



#### 类 继承 super()  抽象类

```js
// 抽象类 不能创建实例对象，创建抽象类就是给子类当爸爸的 用来继承的 加抽象方法为了提示子类必须重写这个类
// 抽象方法只能在抽象类中 继承抽象类的子类必须重写这个抽象方法 否则报错，
abstract class Animal{
    name:string
    age:number
	
    // 实例化类时候 会进入这个constructor函数
    constructor(name:string, age:number){
        this.name = name
        this.age = age
    }

   abstract say():void
}



// 继承 继承了Animal的所有属性和方法 say方法重写  
// 子类可以重写constructor 此时子类可以重写父类的constructor函数 并可以在原父类需要参数基础上多加需要传入的参数
// 但是要super()把原父类参数继承过来 多加的参数赋值到this  this.xx = xx
class Dog extends Animal{
    size:number

    constructor(name:string,age:number,size:number){
        super(name,age)
        this.size = size
    }
    say(): void {
        console.log(`动物: ${this.name} 年龄: ${this.age} 体重: ${this.size} 在叫`)
    }
}


// 继承  继承了Animal的所有属性和方法 say方法重写
class Cat extends Animal{
    say(): void {
        console.log(`动物: ${this.name} 年龄: ${this.age}  在叫`)
    }
}

const dog = new Dog('狗',1, 12)
dog.say()  // 动物: 狗 年龄: 1 体重: 12 在叫

const cat = new Cat('猫',2)
cat.say() // 动物: 猫 年龄: 2  在叫
```



#### 接口

```js
//接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；
//接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；
// 接口interface 类用implements继承接口
interface myInter{
    name: string

    say():void
}
class NeedImp implements myInter{
    name:string
    constructor(name:string){
        this.name = name
    }
    say(): void {
       console.log('大家好')
    }
}


const nd = new NeedImp('我的名子')

//接口属性
class NeedImp implements myInter{

    // public name:string
    // public age:number
    // constructor(name:string,age:number){
    //     this.name = name
    //     this.age = age
    // }


    // 和上面方式一样 不需要再另外定义属性
    constructor( public name:string, public age:number){
    }
    
    //可以直接 set get实例化时候访问这个属性
   	set _name(v : string) {
        this.name = v;
    }
    
    get _name() : string {
        return this.name 
    }         

    say(): void {
       console.log('大家好')
    }
}

const nd = new NeedImp('我的名子',25)
nd._name = 'yang'


```



#### 泛型

- 在定义函数或类时 如果遇到类型不明确就可以使用泛型

  ```js
  //无法确定any类型一直 即输入某个any类型不确定返回也是这个类型 
  function(a:any):any{
      return a
  } 
  
  //定义一个T类型的函数<T> 参数也是T类型 返回值也是T类型:T
  function fn<T>(a:T):T{
       return a
   }
  
  //可以直接调用
  fn(a:10) //不指定泛型 ts可以自动对类型进行推断
  fn<string>(a:'10') //指定string泛型
  
  
  //可以指定多个泛型
  functon fn<T,K>(a:T, b:K):T{
      console.log(b)
      return a
  }
  
  fn(a:123,b:'hello')  
  相当于 fn<number,string>(a:123,b:'hello')  推荐指定泛型类型
  
  //泛型约束
  interface Inter{
      length:number
  }
  //T extends Inter 表示泛型T必须是Inter实现类(子类)
  function fn<T extends Inter>(a:T):number{
      return a.length
  }
  
  class MyClass<T>{
  	name:T;
  	constructor(name:T){
          this.name = name
      }
  }
  
  const mc = new MyClass<string>( name:'孙悟空')
  
  
  ```
  
  





### react

#### 初始化脚手架

```js
npx create-react-app my-app
```

#### JSX注意点

1. React元素的属性名使用驼峰命名法
2. 特殊属性名：
   - class -> className
   - for -> htmlFor
   - tabindex -> tabIndex  
3. 没有子节点的React元素可以用/>结束
4. 推荐：使用小括号包裹JSX 从而避免js中的自动插入分号陷阱
5. 使用单括号 {} 不是双括号，包裹表达式
6. 添加行内样式 使用style={{ color:'red', backgroundColor:'yellow'}} ，推荐使用类名



#### 使用函数创建组件

- 函数组件：使用Js的函数或箭头函数创建的组件
- 函数名称必须大写字母开头
- 函数组件必须有返回值，表示该组件的结构

```js
function Hello(){
    return(
    	<div>第一个组件</div>
    )
}

// 使用箭头函数创建组件
const Hello = () => <div>我是一个组件</div>

ReactDOM.render(<Hello />, document.getElementById('root'))

```



#### 使用类创建组件

- 类组件：使用ES6的class创建组件

- 约定1：类名也必须大写字母开头

- 约定2： 类组件应该继承React.Component父类 从而可以使用父类中提供的方法/属性

- 约定3： 类组件必须提供render()方法

- 约定4： render（）方法必须有返回值，表示该组件的结构

  ```js
  class Hello extends React.Component {
      render(){
          return <div> hello class component!</div>
      }
  }
  ```

  

#### 事件绑定

- React事件绑定语法与DOM事件语法相似
- 语法： on+ 事件名称 = { 事件处理程序 }, onClick ={ ()=>{} }
- 注意：React事件采用驼峰命名法， onMouseEnter onFocus



#### 有状态组件和无状态组件

- 函数组件又叫无状态组件  类组件又叫有状态组件
- 状态(state) 即数据
- 函数组件没有自己的状态 只负责数据展示（静）
- 类组件有自己的状态 负责更新UI 让页面"动"起来



#### state基本使用

- 状态(state)即数据 是组件内部的私有数据，只能在组件内部使用

- state的值是对象，表示一个组件可以有多个数据

- 通过this.state来获取状态

  ```js
  class Hello extends React.Component {
      construtor(){
          super()
          this.state = {
              count: 0
          }
      }
      
    //简写
      state = {
          count: 0
      }
      
      render(){
          return(
          	<div>有状态组件{ this.state.count}</div>
          )
      }
  }
  ```

#### setState修改状态

- 状态是可变的
- 语法：this.setState({要修改的数据})
- 注意：不要直接修改state中的值 这是错误的！！

```js
class App extends React.Component {
	// 简化语法
	state = {
		count: 0,
	}

	render() {
		return (
			<div>
				<div>有状态组件 {this.state.count}</div>
				<button
					onClick={() => {
						this.setState({
							count: this.state.count + 1,
						})
					}}
				>
					+1
				</button>
			</div>
		)
	}
}

整理后  
箭头函数改变this
class App extends React.Component {
	// 简化语法
	state = {
		count: 0,
	}

	onInCrement() {
		this.setState({
			count: this.state.count + 1,
		})
	}

	render() {
        // 箭头函数的this指向外部环境 render()方法
		return (
			<div>
				<div>有状态组件 {this.state.count}</div>
				<button onClick={() => this.onInCrement()}>+1</button>
			</div>
		)
	}
}

class类改变this
class App extends React.Component {
	// 简化语法
	state = {
		count: 0,
	}
	onInCrement = () => {
		this.setState({
			count: this.state.count + 1,
		})
	}
	render() {
		// 箭头函数的this指向外部环境 render()方法
		return (
			<div>
				<div>有状态组件 {this.state.count}</div>
				<button onClick= {this.onInCrement}>+1</button>
			</div>
		)
	}
}

也可以在construtor中使用bind改变this指向

```



#### 受控组件

- 在state中添加一个状态 作为表单元素的value值 (控制表单元素值得来源)
- 给表单元素绑定change事件 将表单元素的值 state的值 (控制表单元素值得变化)

```js
state = {
    txt:''
}

handleChange = e =>{
    this.setState({
        txt: e.target.value
    })
}

<input text="text" value={ this.state.txt} onChange={ this.handleChange}>
```



#### props

- 可以给组件传递任意类型的数据
- props是只读的对象，只能读取属性值无法修改
- 如果在类组件中写了构造函数，要将props传递给super()才能在构造函数中使用props

```js
<Hello name='jack' age={19} />

// 函数组件接受
function Hello(props){
    return(
		<div>接收到的数据: {props.name} </div>    
    )
}

//类组件接受
class Hello extends React.Component {
    render(){
        return(
        	<div>接收到的数据 { this.props.name }</div>
        )
    }
}
    
 
```

##### children



##### props校验

```js
import PropTypes from "prop-types"

App.propTypes = {
    colors:propTypes.array
}
```





#### Context

- 如果两个组件时远房亲戚(比如嵌套多层) 可以使用Context传递数据
- Context提供了两个组件：Provider和Consumer
- Provider提供数据
- Consumer消费数据

```js

//创建context提供的两个组件
const { Provider,Consumer } = React.creatContext()

class App extends React.Component {
    render(){
        return(
        	<Provider value='pink'>
            	<div className="app">
            		<Node />
            	</div>
            </Provider>
        )
    }
}

const Node = props =>{
    return (
    	<div className="node">
        	<SubNode />
        </div>
    )
}

const SubNode = prop =>{
    return(
    	<div className="sub">
        	<Consumer>
        		{ data => <span>我是消耗context的子节点--{ data}</span>}
        	</Consumer>
        	
        </div>
    )
}

```



#### render props模式

- 创建Mouse组件，在组件中提供复用的状态逻辑代码
- 将要复用的状态作为props.fun(state)方法的参数 暴露到组件外部
- 使用props.fun()的返回值作为要渲染的内容



#### 生命周期

![image-20220224231504052](C:\Users\yangjie\AppData\Roaming\Typora\typora-user-images\image-20220224231504052.png)

![image-20220224231952987](C:\Users\yangjie\AppData\Roaming\Typora\typora-user-images\image-20220224231952987.png)



#### 高阶组件

- 创建一个函数 名称约定以with开头
- 指定函数的参数 参数应以大写字母开头(作为要渲染的组件)
- 在函数内部创建一个类组件，提供复用的状态逻辑代码
- 在该组件中，渲染参数组件 同时将状态通过prop传递给参数组件
- 调用该高级组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面

```js

function withMouse(WrappedComponent){
    class Mouse extends React.Component{
        return Mouse
    }
}
```



### Maven

在项目的根目录下执行指令 此目录下必须包含pom.xml

>- 清楚缓存 mvn clean
>- 检查 mvn check
>- 编译 mvn compile
>- 测试 mvn test
>- 打包 mvn package
>- 安装 mvn install
>- 部署 mvn deploye



### ESLint

- env  告诉eslint在那个环境 以至于可以使用当前环境的全局变量

- globals 果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。

  ```js
  {
      "globals": {
          "var1": "writable",
          "var2": "readonly"
      }
  }
  ```

  

### Android

#### gradle与sdk版本

android 版本也即android gradle版本

![image-20220827230354721](C:\Users\yangjie\AppData\Roaming\Typora\typora-user-images\image-20220827230354721.png)



![image-20220828004125971](C:\Users\yangjie\AppData\Roaming\Typora\typora-user-images\image-20220828004125971.png)





